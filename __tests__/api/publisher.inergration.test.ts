// Generated by Copilot
import type { User } from "@prisma/client";
import type { Session } from "next-auth";
import { appRouter } from "~/server/api/root";
import { prisma } from "~/server/db";

beforeAll(async () => {
  // create publishers
  await prisma.publisher.createMany({
    data: [
      {
        name: "publisher1",
        description: "publisher1",
        logo: "publisher1",
      },
      {
        name: "publisher2",
        description: "publisher2",
        logo: "publisher2",
      },
    ],
  });
  console.log("âœ¨ 2 publishers created");
  console.log("On: ", process.env.DATABASE_URL);
});

afterAll(async () => {
  const deletePublishers = prisma.publisher.deleteMany();

  await prisma.$transaction([deletePublishers]);
  console.log("Everything deleted on: ", process.env.DATABASE_URL);
  await prisma.$disconnect();
});

const user: User = {
  id: "1",
  email: "email",
  emailVerified: null,
  image: "image",
  name: "test",
};

describe("When creating a publisher", () => {
  describe("and the user is not authenticated", () => {
    it("should throw an error", async () => {
      // Arrange
      const publisher = {
        name: "publisher3",
        description: "publisher3",
        logo: "publisher3",
      };

      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });
      // Act
      const result = caller.publisher.create(publisher);

      // Assert
      await expect(result).rejects.toThrowError("UNAUTHORIZED");
    });
  });
  describe("and the user is authenticated", () => {
    it("should create a publisher", async () => {
      // Arrange
      const publisher = {
        name: "publisher3",
        description: "publisher3",
        logo: "publisher3",
      };
      const mockSession: Session = {
        expires: new Date().toISOString(),
        user: user,
      };

      const caller = appRouter.createCaller({
        session: mockSession,
        prisma: prisma,
      });
      // Act
      const result = await caller.publisher.create(publisher);
      const newPublisher = await prisma.publisher.findUnique({
        where: {
          id: result.id,
        },
      });

      // Assert
      expect(newPublisher).toMatchObject(publisher);
    });
  });
});

describe("When getting a publisher by Id", () => {
  describe("and the publisher does not exist", () => {
    it("should throw an error", async () => {
      // Arrange
      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });

      // Act
      const result = caller.publisher.getById({ id: "1" });

      // Assert
      await expect(result).rejects.toThrowError();
    });
  });

  describe("and the publisher exists", () => {
    it("should return a publisher", async () => {
      // Arrange
      const data = await prisma.publisher.create({
        data: {
          name: "publisher4",
          description: "publisher4",
          logo: "publisher4",
        },
      });

      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });

      // Act
      const result = await caller.publisher.getById({ id: data.id });

      // Assert
      expect(result).toMatchObject(data);
    });
  });
});

describe("When getting all publishers", () => {
  describe("and there are no publishers", () => {
    it("should return an empty array", async () => {
      // Arrange
      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });
      await prisma.publisher.deleteMany();

      // Act
      const result = await caller.publisher.getAll();

      // Assert
      expect(result).toMatchObject([]);
    });
  });

  describe("and there are publishers", () => {
    it("should return an array of publishers", async () => {
      // Arrange
      const publishers = [
        {
          name: "publisher5",
          description: "publisher5",
          logo: "publisher5",
        },
        {
          name: "publisher6",
          description: "publisher6",
          logo: "publisher6",
        },
      ];

      await prisma.publisher.createMany({
        data: publishers,
      });

      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });

      // Act
      const result = await caller.publisher.getAll();

      // Assert
      expect(result).toMatchObject(publishers);
    });
  });
});

describe("When updating a publisher", () => {
  describe("and the user is not authenticated", () => {
    it("should throw an error", async () => {
      // Arrange
      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });

      // Act
      const result = caller.publisher.update({
        id: "1",
        name: "publisher7",
        description: "publisher7",
        logo: "publisher7",
      });

      // Assert
      await expect(result).rejects.toThrowError();
    });
  });

  describe("and the publisher does not exist", () => {
    it("should throw an error", async () => {
      // Arrange

      const mockSession: Session = {
        expires: new Date().toISOString(),
        user: user,
      };

      const caller = appRouter.createCaller({
        session: mockSession,
        prisma: prisma,
      });

      // Act
      const result = caller.publisher.update({
        id: "1",
        name: "publisher7",
        description: "publisher7",
        logo: "publisher7",
      });

      // Assert
      await expect(result).rejects.toThrowError();
    });
  });

  describe("and the publisher exists", () => {
    it("should update the publisher", async () => {
      // Arrange
      const data = await prisma.publisher.create({
        data: {
          name: "publisher8",
          description: "publisher8",
          logo: "publisher8",
        },
      });

      const mockSession: Session = {
        expires: new Date().toISOString(),
        user: user,
      };

      const caller = appRouter.createCaller({
        session: mockSession,
        prisma: prisma,
      });

      // Act
      const result = await caller.publisher.update({
        id: data.id,
        name: "updated",
        description: "updated",
        logo: "updated",
      });

      // Assert
      expect(result).toMatchObject({
        id: data.id,
        name: "updated",
        description: "updated",
        logo: "updated",
      });
    });
  });
});

describe("When deleting a publisher", () => {
  describe("and the user is not authenticated", () => {
    it("should throw an authentication error", async () => {
      // Arrange
      const caller = appRouter.createCaller({
        session: null,
        prisma: prisma,
      });

      // Act
      const result = caller.publisher.delete({ id: "1" });

      // Assert
      await expect(result).rejects.toThrowError();
    });
  });
  describe("and the publisher does not exist", () => {
    it("should throw an error", async () => {
      // Arrange

      const mockSession: Session = {
        expires: new Date().toISOString(),
        user: user,
      };

      const caller = appRouter.createCaller({
        session: mockSession,
        prisma: prisma,
      });

      // Act
      const result = caller.publisher.delete({ id: "1" });

      // Assert
      await expect(result).rejects.toThrowError();
    });
  });
  describe("and the publisher exists", () => {
    it("should delete the publisher", async () => {
      // Arrange
      const data = await prisma.publisher.create({
        data: {
          name: "publisher9",
          description: "publisher9",
          logo: "publisher9",
        },
      });

      const mockSession: Session = {
        expires: new Date().toISOString(),
        user: user,
      };

      const caller = appRouter.createCaller({
        session: mockSession,
        prisma: prisma,
      });

      // Act
      const result = await caller.publisher.delete({ id: data.id });

      // Assert
      expect(result).toMatchObject(data);
    });
  });
});
